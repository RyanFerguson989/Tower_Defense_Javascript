<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Tower Defense!</title>
    <script src="js/stage1PathCoordinates.js"></script>
    <script src="js/PlacementTiles.js"></script>
    <script type="application/javascript">

    var INTERVAL = 20;
    var DEBUG = false;
    var canvas;             // The canvas shown on the page.
    var ctx;
    const tower = [];
    const enemies = [];
    var count = 0;
    var counts = 0;

    var smallSpriteHeight = 64;
    var smallSpriteWidth = 64;

    var smallSpriteX = 100;
    var smallSpriteY = 300;

    // canvas.width = 1280;
    // canvas.height = 768;

    let activeTile = undefined;

    const backgroundImage = new Image();
    backgroundImage.src = "PNGs/Maps/Stage1TD.png";

    const bugSprite = new Image();
    bugSprite.src = "PNGs/Enemies/Bug.png";

    const tower1 = new Image();
    tower1.src = "PNGs/Towers/tower1-26resize.png";

    const towerprojectile = new Image();
    towerprojectile.src = "PNGs/Projectiles/tower1projectileresize.png";

    // placementTilesMap is inside PlacementTiles.js
    // 2D array for the placement tiles with the symbol that associates them to be a valid placement tile (62 inside PlacementTiles.js)
    const placementTilesSymbol2D = []
    for (let i = 0; i < placementTilesMap.length; i += 20) // increment by 20 because we have 20 columns, i.e how many tiles in each row
    {
      placementTilesSymbol2D.push(placementTilesMap.slice(i, i + 20));
    }

    class PlacementTile {
      constructor({ position = {x: 0, y: 0}})
      {
        this.position = position;
        this.size = 64;
        this.color = 'rgba(255, 255, 255, 0.15)';
        this.occupied = false;
      }

      draw()
      {
        ctx.fillStyle = this.color;
        ctx.fillRect(this.position.x, this.position.y, this.size, this.size);
      }

      update(mouse)
      {
        this.draw();

        if (mouse.x > this.position.x && mouse.x < this.position.x + this.size && mouse.y > this.position.y && mouse.y < this.position.y + this.size)
        {
          // console.log('colliding');
          this.color = 'white';
        }
        else this.color = 'rgba(255, 255, 255, 0.15)';
      }

    }
    
    // Makes an array of placement tile objects that are the same row and column as portrayed in PlacementTiles.js
    const placementTiles = [];
    placementTilesSymbol2D.forEach((row, y) => {
      row.forEach((symbol, x) => {
        if (symbol === 62) {
          placementTiles.push(new PlacementTile({
            position: {
              x: x * 64,  // 64 represents the width and height of the tile
              y: y * 64
            }
          }))
        }
      })
    })
    

    // Base class for all enemy types that are 64x64
    class smallEnemy 
    {
      constructor({ position = { x: 0, y: 0} })   // turns position into an object with x and y properties, each enemy object created must come with it's position 
      {
        this.position = position;                 // Each enemy will have it's own individual position
        this.width = 64;  
        this.height = 64;
        this.coordinateIndex = 0;                 // coordinate index inside stage1Path array
        this.center =                             // point at center of the sprite
        {
          x: this.position.x + this.width / 2,
          y: this.position.y + this.height / 2
        }
        this.radius = 32;

      }

      // draw the small enemy
      draw()
      {
        ctx.drawImage(bugSprite, 0, 0, this.width, this.height, this.position.x, this.position.y, this.width, this.height);

        // draws a circle around the enemy, we can use this to look at collisions
        ctx.beginPath();
        ctx.arc(this.center.x, this.center.y, this.radius, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(255, 0, 132, 0.15)';
        ctx.fill();
      }

      // move the small enemy based on the coordinates taken from stage1PathCoordinates.js
      move()
      {
        this.draw();

        const coordinate = stage1Path[this.coordinateIndex];             // the points where we want the enemy to move to
        const xDistance = coordinate.x - this.center.x;                // get the distance between the enemy x pos and next coordinate x pos
        const yDistance = coordinate.y - this.center.y;                // get the distance between the enemy y pos and next coordinate y pos
        const angle = Math.atan2(yDistance, xDistance);                  // angle at which to move along path
        
        this.position.x += Math.cos(angle);                              // update x position
        this.position.y += Math.sin(angle);                              // update y position
        this.center =                                                    // update center point
        {
          x: this.position.x + this.width / 2,
          y: this.position.y + this.height / 2
        }

        // console.log(Math.round(this.position.x));
        // console.log(Math.round(this.center.x));

        // if the enemy has made it to the coordinate, move to the next coordinate                   && stop at last coordinate (off canvas)
        if (Math.round(this.center.x) === coordinate.x && Math.round(this.center.y) === coordinate.y && this.coordinateIndex < stage1Path.length - 1)
        {
          this.coordinateIndex++;
        }

      
      }

    }

    class Tower
    {
      constructor({ position = { x: 0, y: 0 } })
      {
        this.position = position;
        this.width = 128;
        this.height = 138;
        this.center = {
          x: this.position.x + this.width / 2,
          y: this.position.y + this.height / 2
        }
        this.projectileSpawnPoint = {                // this is the position that we want the projectile to spawn at the height of the tower animation
          x: this.position.x + (this.width / 2) - 20,
          y: this.position.y
        }
        this.projectiles = [];  // an array of new projectile objects with their own position properties          
        this.radius = 300;      // radius of the vision sphere we create, inc/dec this value to adjust range of tower
        this.target;
        this.frames = 0;        // used for how fast the tower shoots

      }

      draw()
      {
        // draw the tower
        ctx.drawImage(tower1, 0, 0, this.width, this.height, this.position.x, this.position.y, this.width, this.height);
        
        // draw the vision sphere
        ctx.beginPath();
        ctx.arc(this.center.x, this.center.y, this.radius, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(0, 220, 255, 0.15)';
        ctx.fill();
      }

      update()
      {
        this.draw();

        // push projectiles into the projectiles array every 50 frames && and if a target is within vision of tower
        // decrease or increase this number to adjust fire rate
        if (this.frames % 50 === 0 && this.target)
        {
          this.projectiles.push(new Projectile({  // each building is responsible for it's own projectiles
            position: {
              x: this.projectileSpawnPoint.x,
              y: this.projectileSpawnPoint.y
            },
            enemy: this.target   // pass in the enemy from the projectiles class, this is helping us do things like check for collision, the target is the first enemy in range of tower (updated inside tick)
          }))
        }
        this.frames++;           // increments every tick cycle
      }

      // rotate()
      // {
      //   var angle = Math.atan2(mouse.y - this.position.y, mouse.x - this.position.x) / Math.PI * 180;
      //   this.rotation = angle;
      // }

    }

    class Projectile
    {
      constructor({position = {x: 0, y:0}, enemy })  // when creating a projectile, pass in the position and the enemy it's targeting
      {
        this.position = position;
        this.width = 31;
        this.height = 25;
        this.velocity = 
        {
          x: 0,
          y: 0
        }
        this.enemy = enemy;
      }

      // this is drawing tower1 projectile
      draw()
      {
        // ctx.beginPath();
        // ctx.arc(this.position.x, this.position.y, 10, 0, Math.PI * 2);
        // ctx.fillStyle = 'orange';
        // ctx.fill();

        ctx.drawImage(towerprojectile, 0, 0, this.width, this.height, this.position.x, this.position.y, this.width, this.height);
      }

      move()
      {
        this.draw();

        // just like with the enemy movement we want the angle of the projectile and the enemies
        const angle = Math.atan2(this.enemy.center.y - this.position.y, this.enemy.center.x - this.position.x );
        const speed = 7;  // how fast the projectile moves

        this.velocity.x = Math.cos(angle) * speed;    // push the projectile on the x axis towards the enemy
        this.velocity.y = Math.sin(angle) * speed;    // push the projectile on the y axis towards the enemy

        this.position.x += this.velocity.x;   // move the projectile's x
        this.position.y += this.velocity.y;   // move the projectile's y

      }
    }

    


    // const bugEnemy = new smallEnemy({ position: { x: stage1Path[0].x, y: stage1Path[0].y } });           // make a bug at positon x and y on the canvas
    
    function drawStage()
    {
      ctx.drawImage(backgroundImage, 0, 0);                                          // draws the background of stage 1
    }

    function createTower(xs,ys,types){
      var spriteImage = new Image();
      spriteImage.src = "PNGs/Towers/Level_1-4.png";
      const newtower = {type:types, x:xs, y:ys,damage:1,range:10,spriteImage:spriteImage,height:128,width:64};
        tower[tower.length] = newtower;


    }

    function createEnemy(types){
      xs = 0;
      ys= 450;
      var spriteImage = new Image();
      spriteImage.src = "PNGs/Enemies/Fly.png";
      const newenemy = {type:types, x:xs, y:ys,speed:1,spriteImage:spriteImage,height:64,width:64,health:100};
        enemies[enemies.length] = newenemy;

    }

    // fill enemies array up with bug enemies, the xOffset positions the next enemy a fixed distance away from the previous enemy
    for (let i = 1; i < 10; i++)
    {
      const xOffset = i * 150;
      enemies.push(new smallEnemy({ position: { x: stage1Path[0].x - xOffset, y: stage1Path[0].y } }));
    }

    function Tick() {

      drawStage();

      // for each bug enemy inside enemies array, move
      enemies.forEach(smallEnemy => {
        smallEnemy.move();
      });

      // for each tile in placementTiles array update the mouse over feature
      placementTiles.forEach(tile => {
        tile.update(mouse);
      })

      tower.forEach(tower => 
      {
        tower.update();
        tower.target = null; // this is nothing before setting it i.e. tower targets nothing at first
        const enemyInRange = enemies.filter(enemy => {
          const xDifference = enemy.center.x - tower.center.x; // x value of distance between center of enemy and tower
          const yDifference = enemy.center.y - tower.center.y; // y value of distance between center of enemy and tower
          const distance = Math.hypot(xDifference, yDifference); // returns square root of the sum of xDif and yDif i.e. pythagorean theorem to find it's length
          return distance < enemy.radius + tower.radius;  // return true if the enemy is inside the vision sphere of the tower
        })
        tower.target = enemyInRange[0]; // target the first enemy that comes within range of tower
        

        // loop thru projectiles array from the end
        for (let i = tower.projectiles.length - 1; i >= 0; i--)
        { 
          // for each tower move a projectile
          const projectile = tower.projectiles[i];
          projectile.move();

          // Check for collision with an enemy and if so, erase the projectile from the projectiles array
          if (projectile.position.x > projectile.enemy.position.x && 
              projectile.position.x < projectile.enemy.position.x + projectile.enemy.width && 
              projectile.position.y > projectile.enemy.position.y && 
              projectile.position.y < projectile.enemy.position.y + projectile.enemy.height)
          {
            tower.projectiles.splice(i, 1);
          }


          // CIRCLES?!?
          //****************************************
          // each projectile will be assigned to an enemy in which the projectile is moving towards
          // const xDifference = projectile.enemy.center.x - projectile.position.x;  
          // const yDifference = projectile.enemy.center.y - projectile.position.y;  
          // const distance = Math.hypot(xDifference, yDifference);

          // console.log(distance);

          // if (distance < projectile.enemy.center + projectile.x)
          // {
          //   tower.projectiles.splice(i, 1);
          // }
          //*******************************************

        }

      })

      


    
    }


    // function Tick2(){
    //   createEnemy(1);
    //   }

// function drawEnemies(){

//   for(let i = 0;i<enemies.length;i++){
//         ctx.clearRect(enemies[i].x, enemies[i].y, enemies[i].width, enemies[i].height);
//       enemies[i].x += enemies[i].speed;

//       ctx.drawImage(enemies[i].spriteImage,0*enemies[i].width,0*enemies[i].height,enemies[i].width,enemies[i].height,enemies[i].x,enemies[i].y,enemies[i].width,enemies[i].height);
// //make it so if it hits edge it gets deleted
//     }

// }
  // function  drawTowers(){
  //     for(let i = 0;i<tower.length;i++){
  //         ctx.drawImage(tower[i].spriteImage,0*tower[i].width,0*tower[i].height,tower[i].width,tower[i].height,tower[i].x,tower[i].y,tower[i].width,tower[i].height)
  //         const whatToRemove = [];
  //         for(let j=0;j<enemies.length;j++){

  //           if((enemies[j].x <= (tower[i].x + (((tower[i].width))*tower[i].range))) && (enemies[j].x  >= (tower[i].x - (((tower[i].width))*tower[i].range))) && (enemies[j].y <= (tower[i].y + (((tower[i].height))*tower[i].range))) && (enemies[j].y >= (tower[i].y - (((tower[i].height))*tower[i].range)))){
  //             enemies[j].health -= tower[i].damage;
  //              document.getElementById("YouWin").innerHTML = (count+ "-killed " + enemies.length);
  //             if(enemies[j].health <= 0){
  //               ctx.clearRect(enemies[j].x, enemies[j].y, enemies[j].width, enemies[j].height);
  //               whatToRemove[whatToRemove.length] = j;
  //             }
  //             break;
  //           }

  //         }
  //         for(let j = 0; j<whatToRemove.length; j++){
  //          enemies.splice(whatToRemove[j],1);
  //          count++;
  //         }
  //         whatToRemove.length = 0;

  //     }
  //   }


    function loadComplete() 
    {
      console.log("Load is complete.");
      canvas = document.getElementById("theCanvas");
      ctx = canvas.getContext("2d");
      ctx.fillStyle = "#ff0000";
      ctx.font = "30px Arial";
      ctx.lineWidth = 50;
      ctx.strokeStyle = 'red';
      drawStage();


      // This lets you click onto a placement tile and draw a tower
      // causes error if moved
      canvas.addEventListener('click', (event) => {
        if (activeTile && !activeTile.occupied) {
          tower.push(new Tower({
            position: {
              x: activeTile.position.x,
              y: activeTile.position.y
            } // push tower into tower array with placement tiles position
          }))
          activeTile.occupied = true;  // this keeps from placing more than one turret on a placement tile
        }
      })

      


      // createTower(200,200,1);
      // createTower(100,100,1);
      // createTower(50,50,1);
      // console.log(stage1Path[1].x);
      // console.log(stage1Path[1].y);

      myInterval = self.setInterval(function () { Tick() }, INTERVAL);
      // myInterval2 = self.setInterval(function(){Tick2()}, INTERVAL*100);

    }

    
    const mouse = {
      x: undefined,
      y: undefined
    }

    // moving mouse over a valid placement tile sets it as an active tile
    window.addEventListener('mousemove', (event) => {
        mouse.x = event.clientX;
        mouse.y = event.clientY;

        activeTile = null;
        for (let i = 0; i < placementTiles.length; i++) {
          const tile = placementTiles[i];
          if (mouse.x > tile.position.x && mouse.x < tile.position.x + tile.size && mouse.y > tile.position.y && mouse.y < tile.position.y + tile.size) // mouse collision with placement tile
          {
            activeTile = tile;
            break;
          }
        }
      })

    </script>
  </head>

 <body onload="loadComplete()" bgcolor="0f0000" text="#ffffff">
 

  <canvas id="theCanvas" tabindex="1" width="1280" height="768"></canvas>
<!-- <h2 id="YouWin">This will update on kill</h2> -->



  </body>
</html>

