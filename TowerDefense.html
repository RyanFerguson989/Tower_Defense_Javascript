<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Tower Defense!</title>
    <script src="js/stage1PathCoordinates.js"></script>
    <script src="js/PlacementTiles.js"></script>
    <script type="application/javascript">

    var INTERVAL = 50;
    var DEBUG = false;
    var canvas;             // The canvas shown on the page.
    var ctx;
    const tower = [];
    const enemies = [];
    var count = 0;
    var counts = 0;

    var smallSpriteHeight = 64;
    var smallSpriteWidth = 64;

    var smallSpriteX = 100;
    var smallSpriteY = 300;

    // canvas.width = 1280;
    // canvas.height = 768;

    let activeTile = undefined;

    const backgroundImage = new Image();
    backgroundImage.src = "PNGs/Maps/Stage1TD.png";

    const bugSprite = new Image();
    bugSprite.src = "PNGs/Enemies/Bug.png";

    const tower1 = new Image();
    tower1.src = "PNGs/Towers/Tower1-1.png";

    const placementTilesSymbol2D = []
    for (let i = 0; i < placementTilesMap.length; i += 20) // increment by 20 because we have 20 columns, i.e how many tiles in each row
    {
      placementTilesSymbol2D.push(placementTilesMap.slice(i, i + 20));
    }

    class PlacementTile {
      constructor({ position = {x: 0, y: 0}})
      {
        this.position = position;
        this.size = 64;
        this.color = 'rgba(255, 255, 255, 0.15)';
        this.occupied = false;
      }

      draw()
      {
        ctx.fillStyle = this.color;
        ctx.fillRect(this.position.x, this.position.y, this.size, this.size);
      }

      update(mouse)
      {
        this.draw();

        if (mouse.x > this.position.x && mouse.x < this.position.x + this.size && mouse.y > this.position.y && mouse.y < this.position.y + this.size)
        {
          // console.log('colliding');
          this.color = 'white';
        }
        else this.color = 'rgba(255, 255, 255, 0.15)';
      }

    }
    
    // Makes an array of placement tile objects that are the same row and column as portrayed in PlacementTiles.js
    const placementTiles = [];
    placementTilesSymbol2D.forEach((row, y) => {
      row.forEach((symbol, x) => {
        if (symbol === 62) {
          placementTiles.push(new PlacementTile({
            position: {
              x: x * 64,
              y: y * 64
            }
          }))
        }
      })
    })
    
    // console.log(placementTiles);

    // Base class for all enemy types that are 64x64
    class smallEnemy 
    {
      constructor({ position = { x: 0, y: 0} })   // turns position into an object with x and y properties, each enemy object created must come with it's position 
      {
        this.position = position;                 // Each enemy will have it's own individual position
        this.width = 64;  
        this.height = 64;
        this.coordinateIndex = 0;                 // coordinate index inside stage1Path array
        this.center =                             // point at center of the sprite
        {
          x: this.position.x + this.width / 2,
          y: this.position.y + this.height / 2
        }

      }

      // draw the small enemy
      draw()
      {
        ctx.drawImage(bugSprite, 0, 0, this.width, this.height, this.position.x, this.position.y, this.width, this.height);
      }

      // move the small enemy based on the coordinates taken from stage1PathCoordinates.js
      move()
      {
        this.draw();

        const coordinate = stage1Path[this.coordinateIndex];             // the points where we want the enemy to move to
        const xDistance = coordinate.x - this.center.x;                // get the distance between the enemy x pos and next coordinate x pos
        const yDistance = coordinate.y - this.center.y;                // get the distance between the enemy y pos and next coordinate y pos
        const angle = Math.atan2(yDistance, xDistance);                  // angle at which to move along path
        
        this.position.x += Math.cos(angle);                              // update x position
        this.position.y += Math.sin(angle);                              // update y position
        this.center =                                                    // update center point
        {
          x: this.position.x + this.width / 2,
          y: this.position.y + this.height / 2
        }

        // console.log(Math.round(this.position.x));
        // console.log(Math.round(this.center.x));

        if (Math.round(this.center.x) === coordinate.x && Math.round(this.center.y) === coordinate.y && this.coordinateIndex < stage1Path.length - 1)
        {
          this.coordinateIndex++;
        }

        


      }

    }

    class Tower
    {
      constructor({ position = { X: 0, y: 0 } })
      {
        this.position = position;
        this.width = 64;
        this.height = 128;
      }

      draw()
      {
        ctx.drawImage(tower1, 0, 0, this.width, this.height, this.position.x, this.position.y, this.width, this.height);
      }

    }

    


    // const bugEnemy = new smallEnemy({ position: { x: stage1Path[0].x, y: stage1Path[0].y } });           // make a bug at positon x and y on the canvas
    



    
    function drawStage()
    {
      ctx.drawImage(backgroundImage, 0, 0);                                          // draws the background of stage 1
    }

    function createTower(xs,ys,types){
      var spriteImage = new Image();
      spriteImage.src = "PNGs/Towers/Level_1-4.png";
      const newtower = {type:types, x:xs, y:ys,damage:1,range:10,spriteImage:spriteImage,height:128,width:64};
        tower[tower.length] = newtower;


    }

    function createEnemy(types){
      xs = 0;
      ys= 450;
      var spriteImage = new Image();
      spriteImage.src = "PNGs/Enemies/Fly.png";
      const newenemy = {type:types, x:xs, y:ys,speed:1,spriteImage:spriteImage,height:64,width:64,health:100};
        enemies[enemies.length] = newenemy;

    }

    // fill enemies array up with bug enemies, the xOffset positions the next enemy a fixed distance away from the previous enemy
    for (let i = 1; i < 10; i++)
    {
      const xOffset = i * 150;
      enemies.push(new smallEnemy({ position: { x: stage1Path[0].x - xOffset, y: stage1Path[0].y } }));
    }

    function Tick() {

      drawStage();

      // for each bug enemy inside enemies array, move
      enemies.forEach(smallEnemy => {
        smallEnemy.move();
      });

      placementTiles.forEach(tile => {
        tile.update(mouse);
      })

      tower.forEach(tower => {
        tower.draw();
      })

      // drawEnemies();
      // drawTowers();

      // console.log(tower);

    
    }


    // function Tick2(){
    //   createEnemy(1);
    //   }

// function drawEnemies(){

//   for(let i = 0;i<enemies.length;i++){
//         ctx.clearRect(enemies[i].x, enemies[i].y, enemies[i].width, enemies[i].height);
//       enemies[i].x += enemies[i].speed;

//       ctx.drawImage(enemies[i].spriteImage,0*enemies[i].width,0*enemies[i].height,enemies[i].width,enemies[i].height,enemies[i].x,enemies[i].y,enemies[i].width,enemies[i].height);
// //make it so if it hits edge it gets deleted
//     }

// }
  // function  drawTowers(){
  //     for(let i = 0;i<tower.length;i++){
  //         ctx.drawImage(tower[i].spriteImage,0*tower[i].width,0*tower[i].height,tower[i].width,tower[i].height,tower[i].x,tower[i].y,tower[i].width,tower[i].height)
  //         const whatToRemove = [];
  //         for(let j=0;j<enemies.length;j++){

  //           if((enemies[j].x <= (tower[i].x + (((tower[i].width))*tower[i].range))) && (enemies[j].x  >= (tower[i].x - (((tower[i].width))*tower[i].range))) && (enemies[j].y <= (tower[i].y + (((tower[i].height))*tower[i].range))) && (enemies[j].y >= (tower[i].y - (((tower[i].height))*tower[i].range)))){
  //             enemies[j].health -= tower[i].damage;
  //              document.getElementById("YouWin").innerHTML = (count+ "-killed " + enemies.length);
  //             if(enemies[j].health <= 0){
  //               ctx.clearRect(enemies[j].x, enemies[j].y, enemies[j].width, enemies[j].height);
  //               whatToRemove[whatToRemove.length] = j;
  //             }
  //             break;
  //           }

  //         }
  //         for(let j = 0; j<whatToRemove.length; j++){
  //          enemies.splice(whatToRemove[j],1);
  //          count++;
  //         }
  //         whatToRemove.length = 0;

  //     }
  //   }


    function loadComplete() 
    {
      console.log("Load is complete.");
      canvas = document.getElementById("theCanvas");
      ctx = canvas.getContext("2d");
      ctx.fillStyle = "#ff0000";
      ctx.font = "30px Arial";
      ctx.lineWidth = 50;
      ctx.strokeStyle = 'red';
      drawStage();


      // This lets you click onto a placement tile and draw a tower
      // causes error if moved
      canvas.addEventListener('click', (event) => {
        if (activeTile && !activeTile.occupied) {
          tower.push(new Tower({
            position: {
              x: activeTile.position.x,
              y: activeTile.position.y
            }
          }))
          activeTile.occupied = true;
        }
      })

      


      // createTower(200,200,1);
      // createTower(100,100,1);
      // createTower(50,50,1);
      // console.log(stage1Path[1].x);
      // console.log(stage1Path[1].y);

      myInterval = self.setInterval(function () { Tick() }, INTERVAL);
      // myInterval2 = self.setInterval(function(){Tick2()}, INTERVAL*100);

    }

    
    const mouse = {
      x: undefined,
      y: undefined
    }


    window.addEventListener('mousemove', (event) => {
        mouse.x = event.clientX;
        mouse.y = event.clientY;

        activeTile = null;
        for (let i = 0; i < placementTiles.length; i++) {
          const tile = placementTiles[i];
          if (mouse.x > tile.position.x && mouse.x < tile.position.x + tile.size && mouse.y > tile.position.y && mouse.y < tile.position.y + tile.size) {
            activeTile = tile;
            break;
          }
        }
        // console.log(activeTile);
      })

    </script>
  </head>

 <body onload="loadComplete()" bgcolor="0f0000" text="#ffffff">
 

  <canvas id="theCanvas" tabindex="1" width="1280" height="768"></canvas>
<!-- <h2 id="YouWin">This will update on kill</h2> -->



  </body>
</html>

